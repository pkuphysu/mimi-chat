<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="user-scalable=no, viewport-fit=cover">
<title>Mimi 弹幕</title>
<style>
body {
	background-attachment: fixed;
	font-family: Verdana, "Helvetica Neue", Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
	min-width: 960px;
	text-align: center;
}
canvas {
	background-size: cover;
	left: 0;
	position: fixed;
	top: 0;
	z-index: -1;
}
#qrcode {
	position: fixed;
	bottom: 20px;
	left: 20px;
	z-index: 100;
	opacity: 0.9;
	color: white;
}
#qrcode img {
	width: 200px;
	border-radius: 20px;
}
</style>
</head>
<body>
<div id="qrcode">
	<br>
	<span>Mimi 弹幕</span>
	<br>
	<span id="channel"></span>
</div>
<script src="https://cdn.jsdelivr.net/npm/qrcode@1/build/qrcode.min.js"></script>
<script>
window.MathJax = {
	svg: {
		fontCache: 'none'
	}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script>
/*
 * Mimi Danmaku
 * Created by Shuqiao Zhang in 2018.
 * https://zhangshuqiao.org
 */

/*
 * This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 */

let channel = prompt("请输入频道名称", "").replace(/\W/g, "") || "default"; //只能由ASCII字符组成且不超过20个字符
document.getElementById("channel").textContent = "频道：" + channel;

QRCode.toDataURL(new URL(`.?channel=${channel}`, window.location).href, (err, url) => {
	const img = new Image();
	img.src = url;
	document.getElementById("qrcode").insertAdjacentElement("afterbegin", img);
});

class Danmaku {
	constructor() {
		this.rows = 15;
		this.speedFactor = 500;
		this.frameRate = 50;

		this.output = [];
		this.last = new Array(this.rows);

		this.createCanvas();
		this.wsinit();

		setInterval(() => {
			this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.output = this.output.filter(item => {
				this.draw(item);
				item.x -= item.speed;
				return item.x >= -item.width;
			});
		}, 1000 / this.frameRate);
	}

	createCanvas() {
		const canvas = document.createElement("canvas");
		const context = canvas.getContext("2d");
		document.body.appendChild(canvas);

		const availableBg = ["sky.jpg", "bg1.jpg", "bg2.jpg"];
		const Bg = availableBg[Math.floor(Math.random() * availableBg.length)];
		canvas.style.backgroundImage = `url(${Bg})`;

		this.canvas = canvas;
		this.context = context;
		window.addEventListener("resize", () => this.resize());
		this.resize();
	}

	wsinit() {
		const serverUrl = new URL("../", window.location);
		serverUrl.protocol = serverUrl.protocol.replace("http", "ws");
		const ws = new WebSocket(serverUrl, "danmaku" + channel);
		const timer = setInterval(() => {
			ws.send("ping");
		}, 30000);

		ws.onopen = () => {
			alert("系统消息：建立连接成功");
		};

		ws.onmessage = event => {
			const msg = JSON.parse(event.data);
			if (!msg.meta || typeof msg.content !== "string") return;
			if (msg.from !== "user") return;
			console.log(msg);
			this.createDanmaku(msg);
		};

		ws.onerror = () => {
			console.log("系统消息：连接失败，请刷新页面或退出重连");
		};

		ws.onclose = () => {
			console.log("系统消息：连接已断开");
			clearInterval(timer);
		};

		this.ws = ws;
	}

	resize() {
		this.canvas.width = window.innerWidth
		this.canvas.height = window.innerHeight;
		this.baseSize = this.canvas.height / this.rows;
	}

	randColor() {
		const colors = ["orange", "red", "blue", "purple", "green", "white"];
		return colors[Math.floor(Math.random() * colors.length)];
	}

	insertDanmaku(danmaku) {
		danmaku.x = this.canvas.width;
		for (let index = 0; index < this.rows; index++) {
			const target = this.last[index];
			let delta;
			if (target) delta = danmaku.x - target.x;
			if (!target || (danmaku.width < target.width && delta > target.width) || (danmaku.width > target.width && delta > danmaku.width * (danmaku.x + target.width) / (danmaku.x + target.width))) {
				danmaku.y = this.baseSize * (index + 1);
				this.last[index] = danmaku;
				this.output.push(danmaku);
				return;
			}
		}
		// Danmaku is dropped if there's no space for it
	}

	createDanmaku(message) {
		let { content, meta: { size, color } } = message;
		const reg = /^#([\da-fA-F]{6}|[\da-fA-F]{3})$/;
		if (!reg.test(color)) color = this.randColor();
		if (typeof size !== "number") size = parseFloat(size);
		if (isNaN(size) || size > 1 || size < 0) size = 1;
		if (content.startsWith("$") && content.endsWith("$")) {
			this.renderMath(content, size, color);
			return;
		}
		const fontSize = this.baseSize * size;
		// Set font to measureText
		this.context.font = `700 ${fontSize}px Microsoft YaHei`;
		const { width } = this.context.measureText(content);
		const danmaku = {
			speed: (this.canvas.width + width) / this.speedFactor,
			content,
			size: fontSize,
			width,
			color
		};
		this.insertDanmaku(danmaku);
	}

	async renderMath(content, size, color) {
		content = content.match(/^\$(.*?)\$$/)[1];
		const svgOut = await MathJax.tex2svgPromise(content, {
			display: false
		});
		const svg = svgOut.querySelector("svg");
		const img = new Image();
		let xml = new XMLSerializer().serializeToString(svg);
		xml = xml.replace(/currentColor/g, color);
		img.src = "data:image/svg+xml;base64," + btoa(xml);
		img.onload = () => {
			const danmaku = {
				speed  : (this.canvas.width + img.width) / this.speedFactor,
				content: img,
				width  : img.width,
				height : img.height
			};
			this.insertDanmaku(danmaku);
		};
	}

	draw(obj) {
		if (typeof obj.content === "string") {
			this.context.font = `700 ${obj.size}px Microsoft YaHei`;
			this.context.fillStyle = obj.color;
			this.context.fillText(obj.content, obj.x, obj.y);
		} else {
			this.context.drawImage(obj.content, obj.x, obj.y, obj.width, obj.height);
		}
	}
}

const danmaku = new Danmaku();
</script>
</body>
</html>
