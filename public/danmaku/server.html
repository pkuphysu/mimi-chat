<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="user-scalable=no, viewport-fit=cover">
<title>Mimi 弹幕服务端</title>
<style>
body {
	background-attachment: fixed;
	font-family: Verdana, "Helvetica Neue", Arial, "PingFang SC", "Microsoft YaHei", sans-serif;
	min-width: 960px;
	text-align: center;
}
canvas {
	background-size: cover;
	left: 0;
	position: fixed;
	top: 0;
	z-index: -1;
}
#qrcode {
	position: fixed;
	bottom: 20px;
	left: 20px;
	z-index: 100;
	opacity: 0.9;
	color: white;
}
#qrcode img {
	width: 200px;
	border-radius: 20px;
}
</style>
</head>
<body>
<div id="qrcode">
	<br>
	<span>Mimi 弹幕</span>
	<br>
	<span id="channel"></span>
</div>
<script src="https://cdn.jsdelivr.net/npm/qrcode@1/build/qrcode.min.js"></script>
<script>
window.MathJax = {
	svg: {
		fontCache: 'none'
	}
};
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<script>
/*
 * Mimi Danmaku
 * Created by Shuqiao Zhang in 2018.
 * https://zhangshuqiao.org
 */

/*
 * This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 */

let channel = prompt("请输入频道名称", "").replace(/\W/g, "") || "default"; //只能由ASCII字符组成且不超过20个字符
document.getElementById("channel").textContent = "频道：" + channel;

QRCode.toDataURL(new URL(`.?channel=${channel}`, window.location).href, (err, url) => {
	const img = new Image();
	img.src = url;
	document.getElementById("qrcode").insertAdjacentElement("afterbegin", img);
});

class Danmaku {
	constructor() {
		this.wsinit();
		this.output = [];

		this.createCanvas();
		window.addEventListener("resize", () => this.resize());
		this.resize();

		setInterval(() => {
			this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.output = this.output.filter(item => {
				this.draw(item);
				item.x -= item.speed;
				let width;
				if (typeof item.content === "string") {
					width = this.context.measureText(item.content).width;
				} else {
					width = item.width;
				}
				return item.x >= -width;
			});
		}, 20);
	}

	createCanvas() {
		const canvas = document.createElement("canvas");
		const context = canvas.getContext("2d");
		document.body.appendChild(canvas);

		const availableBg = ["sky.jpg", "bg1.jpg", "bg2.jpg"];
		const Bg = availableBg[Math.floor(Math.random() * availableBg.length)];
		canvas.style.backgroundImage = `url(${Bg})`;

		this.canvas = canvas;
		this.context = context;
	}

	wsinit() {
		const serverUrl = new URL("../", window.location);
		serverUrl.protocol = serverUrl.protocol.replace("http", "ws");
		const ws = new WebSocket(serverUrl, "danmaku" + channel);
		const timer = setInterval(() => {
			ws.send("ping");
		}, 30000);

		ws.onopen = () => {
			alert("系统消息：建立连接成功");
		};

		ws.onmessage = event => {
			const msg = JSON.parse(event.data);
			if (!msg.meta || typeof msg.content !== "string") return;
			if (msg.from !== "user") return;
			console.log(msg);
			this.createDanmaku(msg);
		};

		ws.onerror = () => {
			console.log("系统消息：连接失败，请刷新页面或退出重连");
		};

		ws.onclose = () => {
			console.log("系统消息：连接已断开");
			clearInterval(timer);
		};

		this.ws = ws;
	}

	resize() {
		this.canvas.width = window.innerWidth
		this.canvas.height = window.innerHeight;
	}

	randColor() {
		const colors = ["orange", "red", "blue", "purple", "green", "white"];
		return colors[Math.floor(Math.random() * colors.length)];
	}

	danmakuFactory(content) {
		const fontSize = this.canvas.height / 10;
		return {
			speed: (this.canvas.width / 500) * (Math.random() * 0.5 + 0.75),
			x    : this.canvas.width,
			y    : Math.random() * this.canvas.height * 4 / 5 + fontSize, //避免高度重复？
			content
		};
	}

	createDanmaku(message) {
		const reg = /^#([\da-fA-F]{6}|[\da-fA-F]{3})$/;
		if (!reg.test(message.meta.color)) message.meta.color = this.randColor();
		const { content, meta: { size, color } } = message;
		const fontSize = this.canvas.height / 10;
		if (content.startsWith("$") && content.endsWith("$")) {
			this.renderMath(message);
			return;
		}
		const danmaku = {
			...this.danmakuFactory(content),
			size : fontSize * size,
			color
		};
		this.output.push(danmaku);
	}

	async renderMath(message) {
		let { content, meta: { size, color } } = message;
		content = content.match(/^\$(.*?)\$$/)[1];
		const svgOut = await MathJax.tex2svgPromise(content, {
			display: false
		});
		const svg = svgOut.querySelector("svg");
		const img = new Image();
		let xml = new XMLSerializer().serializeToString(svg);
		xml = xml.replace(/currentColor/g, color);
		img.src = "data:image/svg+xml;base64," + btoa(xml);
		img.onload = () => {
			const fontSize = this.canvas.height / 10;
			const danmaku = {
				...this.danmakuFactory(img),
				width: img.width,
				height: img.height
			};
			this.output.push(danmaku);
		};
		return svg;
	}

	draw(obj) {
		if (typeof obj.content === "string") {
			this.context.font = `700 ${obj.size}px Microsoft YaHei`;
			this.context.fillStyle = obj.color;
			this.context.fillText(obj.content, obj.x, obj.y);
		} else {
			this.context.drawImage(obj.content, obj.x, obj.y, obj.width, obj.height);
		}
	}
}

const danmaku = new Danmaku();
</script>
</body>
</html>
